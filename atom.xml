<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qczyl&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.qczyl.club/"/>
  <updated>2017-11-01T07:22:47.000Z</updated>
  <id>http://blog.qczyl.club/</id>
  
  <author>
    <name>qczyl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitLab搭建及汉化</title>
    <link href="http://blog.qczyl.club/2017/11/01/GitLab%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%B1%89%E5%8C%96/"/>
    <id>http://blog.qczyl.club/2017/11/01/GitLab搭建及汉化/</id>
    <published>2017-11-01T07:22:47.000Z</published>
    <updated>2017-11-01T07:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="http://blog.qczyl.club/2017/10/18/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Git%E5%90%A7/">上一篇文章</a>简单介绍了Git的优点以及使用。这一篇就来介绍一下GitLab的搭建。</p>
<hr>
<p>作为公司的话，肯定不希望自己的代码放在别人的网站上，所以搭建一个自己的Git仓库就显得十分必要了（当然，如果你的公司不在意的话，那也是没有问题的）。<a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a>就是一款可以搭建在自己服务器上的Git仓库。</p>
<p>而且GitLab的搭建非常简单，只需三四步的操作即可。</p>
<ol>
<li><p>首先，需要一台服务器，这是最基本的。</p>
<ul>
<li>但是有几点需要注意的：</li>
<li>GitLab官网上强烈推荐承载 GitLab 运行的服务器 至少分配4GB的内存 给 GitLab 。</li>
<li>推荐使用以下几种操作系统的服务器，可以使用Omnibus包安装方法，操作简单。<img src="http://ocga9x543.bkt.clouddn.com/WX20171101-141806.png" alt=""></li>
</ul>
</li>
<li><p>打开<a href="https://about.gitlab.com/installation/" target="_blank" rel="external">GitLab</a>或<a href="https://www.gitlab.cc/installation/" target="_blank" rel="external">GitLab中文网</a>，选择对应的操作系统，按照提示进行安装。推荐使用<code>Omnibus包安装方法</code>进行安装！</p>
<ul>
<li>这里也有一些注意点：</li>
<li>选择对应的操作系统后，会有两种版本的安装方法。</li>
<li><code>Community Edition</code>: 社区版（免费）</li>
<li><code>Enterprise Edition</code>: 企业版（收费）</li>
<li>但是这里推荐安装<code>企业版</code>的。<code>企业版</code>未付费的话，和<code>社区版</code>功能是一样的，付费后可直接使用<code>企业版</code>的功能。而<code>社区版</code>要升级为<code>企业版</code>的话需要重新部署。</li>
</ul>
</li>
<li><p>配置SMTP</p>
<ul>
<li><p>进入<code>/etc/gitlab/gitlab.rb</code>文件，将以下配置的注释取消并修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">gitlab_rails[&apos;smtp_enable&apos;] = true</div><div class="line">gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.server&quot;</div><div class="line">gitlab_rails[&apos;smtp_port&apos;] = 465</div><div class="line">gitlab_rails[&apos;smtp_user_name&apos;] = &quot;smtp user&quot;</div><div class="line">gitlab_rails[&apos;smtp_password&apos;] = &quot;smtp password&quot;</div><div class="line">gitlab_rails[&apos;smtp_domain&apos;] = &quot;example.com&quot;</div><div class="line">gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;</div><div class="line">gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true</div><div class="line">gitlab_rails[&apos;smtp_openssl_verify_mode&apos;] = &apos;peer&apos;</div><div class="line"></div><div class="line"># 如果你使用的SMTP服务是默认的 &apos;From:gitlab@localhost&apos;</div><div class="line"># 你可以修改这里的 &apos;From&apos; 的值。</div><div class="line">gitlab_rails[&apos;gitlab_email_from&apos;] = &apos;gitlab@example.com&apos;</div><div class="line">gitlab_rails[&apos;gitlab_email_reply_to&apos;] = &apos;noreply@example.com&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>* 注：上面只是一个例子，具体的SMTP配置还需要自己根据实际情况修改（修改完配置后记得执行``sudo gitlab-ctl reconfigure``使配置生效）
* 常用的SMTP配置示例可以去[这里](https://docs.gitlab.com.cn/omnibus/settings/smtp.html)查看。
* 配置完成后可以用Rails控制台验证邮件是否能发送成功。 在GitLab服务器上，执行``gitlab-rails console``进入控制台。 然后在控制台提示符后输入下面的命令 发送一封测试邮件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	irb(main):003:0&gt; Notify.test_email(&apos;destination_email@address.com&apos;, &apos;Message Subject&apos;, &apos;Message Body&apos;).deliver_now</div><div class="line"># 示例</div><div class="line">Notify.test_email(&apos;收件人邮箱&apos;, &apos;邮件标题&apos;, &apos;邮件正文&apos;).deliver_now</div></pre></td></tr></table></figure>
</code></pre><p>如果你的测试邮件发送成功了的话，那么恭喜你，GitLab已经搭建完成了，可以尽情的使用了。</p>
<hr>
<p>下面要介绍的就是GitLab的汉化，个人感觉汉化的也不是很完整，导致部分页面是中文英文混杂着的，当然，大部分已经汉化了。</p>
<p>首先确认版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</div></pre></td></tr></table></figure>
<p> v7 ~ v8.8版本clone以下仓库到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://gitlab.com/larryli/gitlab.git</div></pre></td></tr></table></figure>
<p> v8.9以后版本clone以下仓库到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://gitlab.com/xhang/gitlab.git</div></pre></td></tr></table></figure>
<p> clone仓库成功后，比较汉化分支和原分支，导出 patch 用的 diff 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// $&#123;gitlab_version&#125;替换为你上面确定的版本</div><div class="line">git diff v$&#123;gitlab_version&#125; v$&#123;gitlab_version&#125;-zh &gt; ../$&#123;gitlab_version&#125;-zh.diff</div></pre></td></tr></table></figure>
<p>执行完毕后将生成当前版本的补丁文件，如<code>9.0.0-zh.diff</code></p>
<p>导入汉化补丁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 停止 gitlab</div><div class="line">sudo gitlab-ctl stop</div><div class="line">sudo patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 9.0.0-zh.diff</div></pre></td></tr></table></figure>
<p>确定没有 .rej 文件，重启 GitLab 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gitlab-ctl start</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.qczyl.club/2017/10/18/%E5%BC%80%E5%A7%8B%E4%BD%BF
    
    </summary>
    
      <category term="杂学" scheme="http://blog.qczyl.club/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>开始使用Git吧</title>
    <link href="http://blog.qczyl.club/2017/10/18/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Git%E5%90%A7/"/>
    <id>http://blog.qczyl.club/2017/10/18/开始使用Git吧/</id>
    <published>2017-10-18T08:04:51.000Z</published>
    <updated>2017-10-18T08:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>既然说<code>开始使用Git吧</code>，那Git相对于SVN来说肯定还是有一定的好处的。<br>大家可以看一下<a href="https://my.oschina.net/u/1580062/blog/214850" target="_blank" rel="external">评《GIT和SVN之间的五个基本区别》</a>这篇文章，虽然文章时间有点久远，但是我很认同里边的说法，特别是Git对分支和合并有更好的支持。</p>
<p>虽然评论区还是有很多使用SVN的用户不是很赞同他的观点，认为Git的权限问题是一个很大的问题，但是现在公司搭一个Gitlab就可以将权限问题完全搞定了。</p>
<h3 id="Git的基本使用"><a href="#Git的基本使用" class="headerlink" title="Git的基本使用"></a>Git的基本使用</h3><p>Git相对于SVN来说命令确实多了一些，大家可以通过<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80" target="_blank" rel="external">Git基础</a>来学习一下Git的常用命令。</p>
<p>但是个人推荐直接使用<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Sourcetree</a>来进行日常的开发使用，简单方便可视化。当然命令还是要了解一下的，以防万一啊！</p>
<h3 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h3><p>了解了Git的简单命令，以及<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Sourcetree</a>的使用，大家就可以<code>开始使用Git</code>了。</p>
<p>但是，只使用本地仓库的话，那就丧失了Git的真正意义。<br>这里介绍几款Git远程仓库：</p>
<ol>
<li><a href="https://github.com/" target="_blank" rel="external">GItHub</a>，相信这个大家都知道的，但是在<code>GItHub</code>上使用私有仓库是收费的</li>
<li><a href="https://gitee.com/" target="_blank" rel="external">码云</a>，很屌的名字，支持私用仓库创建</li>
<li><a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a>，可搭建在自己的服务器上，适合公司使用，有完善的权限系统</li>
</ol>
<h3 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h3><p>当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果在你的团队中还没有能形成一个特定有效的工作流程，那么混乱就将是不可避免的。</p>
<p>Git工作流程有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大。这里介绍几种公司最常用的Git工作流程：</p>
<ol>
<li><a href="http://blog.jobbole.com/76847/" target="_blank" rel="external">集中式工作流</a>，适合开发团队成员已经很熟悉SVN，无需去适应一个全新流程</li>
<li><a href="http://blog.jobbole.com/76857/" target="_blank" rel="external">功能分支工作流</a>，以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发</li>
<li><a href="http://blog.jobbole.com/76867/" target="_blank" rel="external">Gitflow工作流</a>，通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。最早诞生、并得到广泛采用的一种工作流程，推荐的流程</li>
<li><a href="http://blog.jobbole.com/76861/" target="_blank" rel="external">Forking工作流</a>，分布式工作流，充分利用了Git在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交</li>
</ol>
<p>个人推荐使用<a href="http://blog.jobbole.com/76867/" target="_blank" rel="external">Gitflow工作流</a>，而且<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Sourcetree</a>也天然支持Gitflow，并把这个模型的各种操作通过菜单命令的形式提供了出来，大大减轻了使用人员的学习使用成本。</p>
<hr>
<p>相信大家使用Git后，会渐渐的爱上他的！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然说&lt;code&gt;开始使用Git吧&lt;/code&gt;，那Git相对于SVN来说肯定还是有一定的好处的。&lt;br&gt;大家可以看一下&lt;a href=&quot;https://my.oschina.net/u/1580062/blog/214850&quot; target=&quot;_blank&quot; rel=&quot;e
    
    </summary>
    
      <category term="杂学" scheme="http://blog.qczyl.club/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift 4.0 新特性</title>
    <link href="http://blog.qczyl.club/2017/10/17/Swift%204.0%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.qczyl.club/2017/10/17/Swift 4.0 新特性/</id>
    <published>2017-10-17T09:52:41.000Z</published>
    <updated>2017-10-17T10:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是基于github上一个Swift 4.0新特性的开源项目<a href="https://github.com/ole/whats-new-in-swift-4" target="_blank" rel="external">whats-new-in-swift-4</a>的解读。</p>
<h2 id="1-One-sided-ranges"><a href="#1-One-sided-ranges" class="headerlink" title="1.One-sided ranges"></a>1.One-sided ranges</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let numbers = [1,2,3,4,5,6,7,8,9,10]</div><div class="line">numbers[5...] // instead of numbers[5..&lt;numbers.endIndex]</div></pre></td></tr></table></figure>
<h2 id="2-Strings"><a href="#2-Strings" class="headerlink" title="2.Strings"></a>2.Strings</h2><ul>
<li><p>更快的字符处理速度</p>
<p>  Swift 4 的字符串优化了底层实现，对于英语、法语、德语、西班牙语的处理速度提高了 3.5 倍，对于简体中文、日语的处理速度提高了 2.5 倍</p>
</li>
<li><p>Multi-line string literals 多行字符串字面量</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Swift 4 可以把字符串写在一对 &quot;&quot;&quot; 中，这样字符串就可以写成多行。</div><div class="line">let multilineString = &quot;&quot;&quot;</div><div class="line">    This is a multi-line string.</div><div class="line">    You don&apos;t have to escape &quot;quotes&quot; in here.</div><div class="line">    String interpolation works as expected: 2 + 3 = \(2 + 3)</div><div class="line">    The position of the closing delimiter</div><div class="line">      controls whitespace stripping.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    </div><div class="line">// 当然，也可以使用 \ 来转义换行</div><div class="line">let escapedNewline = &quot;&quot;&quot;</div><div class="line">    To omit a line break, \</div><div class="line">    add a backslash at the end of a line.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">// To omit a line break, add a backslash at the end of a line.</div></pre></td></tr></table></figure>
<ul>
<li><p>去掉 characters</p>
<p>  Swift 3 中的 String 需要通过 characters 去调用的属性方法，在 Swift 4 中可以通过 String 对象本身直接调用，例如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let values = &quot;one,two,three...&quot;</div><div class="line">var i = values.characters.startIndex</div><div class="line">while let comma = values.characters[i...&lt;values.characters.endIndex].index(of: &quot;,&quot;) &#123;</div><div class="line">    if values.characters[i..&lt;comma] == &quot;two&quot; &#123;</div><div class="line">        print(&quot;found it!&quot;)</div><div class="line">    &#125;</div><div class="line">    i = values.characters.index(after: comma)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift 4 可以把上面代码中的所有的 characters 都去掉，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let values = &quot;one,two,three...&quot;</div><div class="line">var i = values.startIndex</div><div class="line">while let comma = values[i...&lt;values.endIndex].index(of: &quot;,&quot;) &#123;</div><div class="line">    if values[i..&lt;comma] == &quot;two&quot; &#123;</div><div class="line">        print(&quot;found it!&quot;)</div><div class="line">    &#125;</div><div class="line">    i = values.index(after: comma)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>String 当做 Collection 来用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 遍历字符串</div><div class="line">let greeting = &quot;Hello, 😜!&quot;</div><div class="line">greeting.count</div><div class="line">for char in greeting &#123;</div><div class="line">    print(char)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 翻转字符串</div><div class="line">let abc: String = &quot;abc&quot;</div><div class="line">print(String(abc.reversed()))</div></pre></td></tr></table></figure>
<ul>
<li>Substring</li>
</ul>
<p><img src="http://ocga9x543.bkt.clouddn.com/QQ20170609-182237@2x.png" alt=""></p>
<p>在 Swift 中，String 的背后有个 Owner Object 来跟踪和管理这个 String，String 对象在内存中的存储由内存其实地址、字符数、指向 Owner Object 指针组成。Owner Object 指针指向 Owner Object 对象，Owner Object 对象持有 String Buffer。当对 String 做取子字符串操作时，子字符串的 Owner Object 指针会和原字符串指向同一个对象，因此子字符串的 Owner Object 会持有原 String 的 Buffer。当原字符串销毁时，由于原字符串的 Buffer 被子字符串的 Owner Object 持有了，原字符串 Buffer 并不会释放，造成极大的内存浪费。</p>
<p>在 Swift 4 中，做取子串操作的结果是一个 Substring 类型，它无法直接赋值给需要 String 类型的地方。必须用 String() 包一层，系统会通过复制创建出一个新的字符串对象，这样原字符串在销毁时，原字符串的 Buffer 就可以完全释放了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let big = downloadHugeString()</div><div class="line">let small = extractTinyString(from: big)</div><div class="line">mainView.titleLabel.text = small // Swift 4 编译报错</div><div class="line">mainView.titleLabel.text = String(small) // 编译通过</div></pre></td></tr></table></figure>
<ul>
<li><p>Unicode</p>
<p>  改善了在计算Unicode字符长度时的正确性。<br>  在 Unicode 中，有些字符是由几个其它字符组成的，比如 é 这个字符，它可以用 \u{E9} 来表示，也可以用 e 字符和上面一撇字符组合在一起表示 \u{65}\u{301}。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var family = &quot;👩&quot;      // &quot;👩&quot;</div><div class="line">family += &quot;\u&#123;200D&#125;👩” // &quot;👩‍👩&quot;</div><div class="line">family += &quot;\u&#123;200D&#125;👧” //&quot;👩‍👩‍👧&quot;</div><div class="line">family += &quot;\u&#123;200D&#125;👦” //&quot;👩‍👩‍👧‍👦&quot;</div><div class="line">family.count          //在swift3中，count=4，在swift4中，count=1</div></pre></td></tr></table></figure>
<h2 id="3-Private-declarations-visible-in-same-file-extensions-修改了Private修饰符的权限范围"><a href="#3-Private-declarations-visible-in-same-file-extensions-修改了Private修饰符的权限范围" class="headerlink" title="3.Private declarations visible in same-file extensions 修改了Private修饰符的权限范围"></a>3.Private declarations visible in same-file extensions 修改了Private修饰符的权限范围</h2><p>private修饰的属性或方法，可以在同文件中的extension中访问到。跟swift3中的fileprivate相似而又不同。相同点是都可以在同一个文件中访问到，不同点是private修饰的只能在当前类型的extension中访问到，而fileprivate修饰的，也可以在其他的类型定义和extension中访问到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct SortedArray&lt;Element: Comparable&gt; &#123;</div><div class="line">    private var storage: [Element] = []</div><div class="line">    init(unsorted: [Element]) &#123;</div><div class="line">        storage = unsorted.sorted()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension SortedArray &#123;</div><div class="line">    mutating func insert(_ element: Element) &#123;</div><div class="line">        // storage is visible here</div><div class="line">        storage.append(element)</div><div class="line">        storage.sort()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let array = SortedArray(unsorted: [3,1,2])</div><div class="line"></div><div class="line">// storage is _not_ visible here. It would be if it were fileprivate.</div><div class="line">//array.storage // error: &apos;storage&apos; is inaccessible due to &apos;private&apos; protection level</div></pre></td></tr></table></figure>
<h2 id="4-Key-Paths"><a href="#4-Key-Paths" class="headerlink" title="4.Key Paths"></a>4.Key Paths</h2><p>类似Objective-C里的KVC，Swift 4.0里的Key Paths是强类型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct Person &#123;</div><div class="line">  var name: String</div><div class="line">&#125;</div><div class="line">struct Book &#123;</div><div class="line">  var title: String</div><div class="line">  var authors: [Person]</div><div class="line">  var primaryAuthor: Person &#123;</div><div class="line">      return authors.first!</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let abelson = Person(name: &quot;Harold Abelson&quot;)</div><div class="line">let sussman = Person(name: &quot;Gerald Jay Sussman&quot;)</div><div class="line">var sicp = Book(title: &quot;Structure and Interpretation of Computer Programs&quot;, authors: [abelson, sussman])</div></pre></td></tr></table></figure>
<ul>
<li>使用key paths获取对象值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sicp[keyPath: \Book.title] </div><div class="line">//Structure and Interpretation of Computer Programs</div></pre></td></tr></table></figure>
<ul>
<li>key paths 可以用于计算属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sicp[keyPath: \Book.primaryAuthor.name] </div><div class="line">//Harold Abelson</div></pre></td></tr></table></figure>
<ul>
<li>使用key paths可以修改值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sicp[keyPath: \Book.title] = &quot;Swift 4.0” </div><div class="line">//sicp.title 现在是Swift 4.0</div></pre></td></tr></table></figure>
<ul>
<li>key paths是对象，可以被存储和操纵</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let authorKeyPath = \Book.primaryAuthor</div><div class="line">print(type(of: authorKeyPath)) //KeyPath&lt;Book, Person&gt;</div><div class="line">let nameKeyPath = authorKeyPath.appending(path: \.name) // 这个可以省略Book，因为编译器可以推断出类型</div><div class="line">sicp[keyPath: nameKeyPath] //Harold Abelson</div></pre></td></tr></table></figure>
<ul>
<li>KeyPath实际上是一个class，它的定义如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/// A key path from a specific root type to a specific resulting value type.</div><div class="line">public class KeyPath&lt;Root, Value&gt; : PartialKeyPath&lt;Root&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>key paths暂时还不支持下标操纵</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//sicp[keyPath: \Book.authors[0].name] //编译失败</div></pre></td></tr></table></figure>
<h2 id="5-Archival-and-serialization归档和序列化"><a href="#5-Archival-and-serialization归档和序列化" class="headerlink" title="5.Archival and serialization归档和序列化"></a>5.Archival and serialization归档和序列化</h2><p>当需要将一个对象持久化时，需要把这个对象序列化，往常的做法是实现 NSCoding 协议，写过的人应该都知道实现 NSCoding 协议的代码写起来很痛苦，尤其是当属性非常多的时候。</p>
<p>Swift 4 中引入了<code>Codable</code>帮我们解决了这个问题。</p>
<p><code>Codable</code>其实是一个组合协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public typealias Codable = Decodable &amp; Encodable</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct Card: Codable &#123;</div><div class="line">    enum Suit: String, Codable &#123;</div><div class="line">        case clubs, spades, hearts, diamonds</div><div class="line">    &#125;</div><div class="line">    enum Rank: Int, Codable &#123;</div><div class="line">        case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king</div><div class="line">    &#125;</div><div class="line">    var suit: Suit</div><div class="line">    var rank: Rank</div><div class="line">&#125;</div><div class="line">let hand = [Card(suit: .clubs, rank: .ace), Card(suit: .hearts, rank: .queen)]</div></pre></td></tr></table></figure>
<p>Encode 操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// json</div><div class="line">var encoder = JSONEncoder()</div><div class="line">let jsonData = try encoder.encode(hand)</div><div class="line">String(data: jsonData, encoding: .utf8)</div><div class="line"></div><div class="line">// plist</div><div class="line">var encoder2 = PropertyListEncoder()</div><div class="line">encoder2.outputFormat = .xml</div><div class="line">let propertyData = try encoder2.encode(hand)</div><div class="line">String(data: propertyData, encoding: .utf8)</div></pre></td></tr></table></figure>
<p>Decode 操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// json</div><div class="line">let decoder = JSONDecoder()</div><div class="line">let decodedHand = try decoder.decode([Card].self, from: jsonData)</div><div class="line"></div><div class="line">// plist</div><div class="line">var decoder2 = PropertyListDecoder()</div><div class="line">let hand3 = try decoder2.decode([Card].self, from: propertyData)</div><div class="line">hand3[0].suit //clubs</div></pre></td></tr></table></figure>
<p>更全面的JSON解析请查看<a href="https://bignerdcoding.com/archives/37.html" target="_blank" rel="external">Swift 4 JSON 解析指南</a></p>
<h2 id="6-Associated-type-constraints关联类型约束"><a href="#6-Associated-type-constraints关联类型约束" class="headerlink" title="6.Associated type constraints关联类型约束"></a>6.Associated type constraints关联类型约束</h2><ul>
<li>protocol中也可以使用<code>where</code>语句对关联类型进行约束了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol where Self: UICollectionViewCell &#123;</div><div class="line">&#125;</div><div class="line">// SomeProtocol要求它的实现者必须继承UICollectionViewCell，</div><div class="line">// 不是随便一个类型都能实现SomeProtocol</div></pre></td></tr></table></figure>
<ul>
<li><code>Sequence</code>协议有自己的<code>Element associatedtype</code>了，不需要写<code>Iterator.Element</code>了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">extension Sequence where Element: Numeric &#123;</div><div class="line">    var sum: Element &#123;</div><div class="line">        var result: Element = 0</div><div class="line">        for element in self &#123;</div><div class="line">            result += element</div><div class="line">        &#125;</div><div class="line">        return result</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[1,2,3,4].sum</div></pre></td></tr></table></figure>
<h2 id="7-Dictionary-and-Set-enhancements"><a href="#7-Dictionary-and-Set-enhancements" class="headerlink" title="7.Dictionary and Set enhancements"></a>7.Dictionary and Set enhancements</h2><ul>
<li>使用key-value sequence初始化Dictionary</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let names = [&quot;Cagney&quot;, &quot;Lacey&quot;, &quot;Bensen”]</div><div class="line">let dict = Dictionary(uniqueKeysWithValues: zip(1..., names))</div><div class="line">//[2: &quot;Lacey&quot;, 3: &quot;Bensen&quot;, 1: &quot;Cagney”]</div></pre></td></tr></table></figure>
<ul>
<li>如果key存在重复的情况，使用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let users = [(1, &quot;Cagney&quot;), (2, &quot;Lacey&quot;), (1, &quot;Bensen”)] </div><div class="line">//zip函数的作用就是把两个Sequence合并成一个key-value元组的Sequence</div><div class="line">let dict = Dictionary(users, uniquingKeysWith: &#123;</div><div class="line">  (first, second) in</div><div class="line">  print(first, second)</div><div class="line">  return first</div><div class="line">&#125;)</div><div class="line">//[2: &quot;Lacey&quot;, 1: &quot;Cagney”]</div></pre></td></tr></table></figure>
<ul>
<li>merge 合并</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let defaults = [&quot;foo&quot;: false, &quot;bar&quot;: false, &quot;baz&quot;: false]</div><div class="line">var options = [&quot;foo&quot;: true, &quot;bar&quot;: false]</div><div class="line">// 按照merge函数的注释应该是如下写法，但是这种写法会报错error: generic parameter &apos;S&apos; could not be inferred</div><div class="line">//let mergedOptions = options.merge(defaults) &#123; (old, _) in old &#125;</div><div class="line">// 需要替换成</div><div class="line">options.merge(defaults.map &#123; $0 &#125;) &#123; (old, _) in old &#125;options</div><div class="line">//[&quot;bar&quot;: false, &quot;baz&quot;: false, &quot;foo&quot;: true]</div></pre></td></tr></table></figure>
<ul>
<li><p>带默认值的下标操作</p>
<p>  使用下标取某个key值时，可以传一个default参数作为默认值，当这个key不存在时，会返回这个默认值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let source = &quot;how now brown cow&quot;</div><div class="line">var frequencies: [Character: Int] = [:]</div><div class="line">for c in source &#123;</div><div class="line">  frequencies[c, default: 0] += 1</div><div class="line">&#125;</div><div class="line">print(frequencies)</div><div class="line">//[&quot;b&quot;: 1, &quot;w&quot;: 4, &quot;r&quot;: 1, &quot;c&quot;: 1, &quot;n&quot;: 2, &quot;o&quot;: 4, &quot; &quot;: 3, &quot;h&quot;: 1]</div></pre></td></tr></table></figure>
<ul>
<li>map和filter函数返回值类型是Dictionary，而不是Array</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let filtered = dict.filter &#123;</div><div class="line">  $0.key % 2 == 0</div><div class="line">&#125;</div><div class="line">filtered //[2: &quot;Lacey&quot;]</div><div class="line">let mapped = dict.mapValues &#123; value in</div><div class="line">  value.uppercased()</div><div class="line">&#125;</div><div class="line">mapped //[2: &quot;LACEY&quot;, 1: &quot;CAGNEY”]</div></pre></td></tr></table></figure>
<ul>
<li>对Sequence进行分组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let contacts = [&quot;Julia&quot;, &quot;Susan&quot;, &quot;John&quot;, &quot;Alice&quot;, &quot;Alex&quot;]</div><div class="line">let grouped = Dictionary(grouping: contacts, by: &#123; $0.first! &#125;)</div><div class="line">print(grouped)</div><div class="line">//[&quot;J&quot;: [&quot;Julia&quot;, &quot;John&quot;], &quot;S&quot;: [&quot;Susan&quot;], &quot;A&quot;: [&quot;Alice&quot;, &quot;Alex&quot;]]</div></pre></td></tr></table></figure>
<h2 id="8-MutableCollection-swapAt-method"><a href="#8-MutableCollection-swapAt-method" class="headerlink" title="8.MutableCollection.swapAt method"></a>8.MutableCollection.swapAt method</h2><p>新增的一个方法，用于交换MutableCollection中的两个位置的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5]</div><div class="line">numbers.swapAt(0,1) </div><div class="line">//[2, 1, 3, 4, 5]</div></pre></td></tr></table></figure>
<h2 id="9-Generic-subscripts泛型下标"><a href="#9-Generic-subscripts泛型下标" class="headerlink" title="9.Generic subscripts泛型下标"></a>9.Generic subscripts泛型下标</h2><p>有时候会写一些数据容器，Swift 支持通过下标来读写容器中的数据，但是如果容器类中的数据类型定义为泛型，以前的下标语法就只能返回 Any，在取出值后需要用 as? 来转换类型。Swift 4 定义下标也可以使用泛型了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct GenericDictionary&lt;Key: Hashable, Value&gt; &#123;</div><div class="line">    private var data: [Key: Value]</div><div class="line">    </div><div class="line">    init(data: [Key: Value]) &#123;</div><div class="line">        self.data = data</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    subscript&lt;T&gt;(key: Key) -&gt; T? &#123;</div><div class="line">        return data[key] as? T</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let dictionary = GenericDictionary(data: [&quot;Name&quot;: &quot;Xiaoming&quot;])</div><div class="line">let name: String? = dictionary[&quot;Name&quot;] // 不需要再写 as? String</div></pre></td></tr></table></figure>
<h2 id="10-NSNumber-bridging-and-Numeric-types"><a href="#10-NSNumber-bridging-and-Numeric-types" class="headerlink" title="10.NSNumber bridging and Numeric types"></a>10.NSNumber bridging and Numeric types</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let n = NSNumber(value: 999)</div><div class="line">let v = n as? UInt8 // Swift 4: nil, Swift 3: 231</div></pre></td></tr></table></figure>
<p>在 Swift 4 中，把一个值为 999 的 NSNumber 转换为 UInt8 后，能正确的返回 nil，而在 Swift 3 中会不可预料的返回 231。</p>
<h2 id="11-减少隐式-objc-自动推断"><a href="#11-减少隐式-objc-自动推断" class="headerlink" title="11.减少隐式 @objc 自动推断"></a>11.减少隐式 @objc 自动推断</h2><p>在项目中想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc，例如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MyClass: NSObject &#123;</div><div class="line">    func print() &#123; ... &#125; // 包含隐式的 @objc</div><div class="line">    func show() &#123; ... &#125; // 包含隐式的 @objc</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样很多并不需要暴露给 Objective-C 也被加上了 @objc。大量 @objc 会导致二进制文件大小的增加。</p>
<p>在 Swift 4 中，隐式 @objc 自动推断只会发生在很少的当必须要使用 @objc 的情况，比如：</p>
<ol>
<li>复写父类的 Objective-C 方法</li>
<li>符合一个 Objective-C 的协议<br>其它大多数地方必须手工显示的加上 @objc。</li>
</ol>
<p>减少了隐式 @objc 自动推断后，Apple Music app 的包大小减少了 5.7%。</p>
<h2 id="12-类型和协议的组合类型"><a href="#12-类型和协议的组合类型" class="headerlink" title="12.类型和协议的组合类型"></a>12.类型和协议的组合类型</h2><p>协议与协议可以组合，协议与class也可以组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">protocol HeaderView &#123;&#125;</div><div class="line"></div><div class="line">class ViewController: UIViewController &#123;</div><div class="line">    let header: UIView &amp; HeaderView</div><div class="line"></div><div class="line">    init(header: UIView &amp; HeaderView) &#123;</div><div class="line">        self.header = header</div><div class="line">        super.init(nibName: nil, bundle: nil)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    required init(coder decoder: NSCoder) &#123;</div><div class="line">        fatalError(&quot;not implemented&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Can&apos;t pass in a simple UIView that doesn&apos;t conform to the protocol</div><div class="line">//ViewController(header: UIView())</div><div class="line">// error: argument type &apos;UIView&apos; does not conform to expected type &apos;UIView &amp; HeaderView&apos;</div><div class="line"></div><div class="line">// Must pass in an NSView (subclass) that also conforms to the protocol</div><div class="line">extension UIImageView: HeaderView &#123;&#125;</div><div class="line"></div><div class="line">ViewController(header: UIImageView()) // works</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是基于github上一个Swift 4.0新特性的开源项目&lt;a href=&quot;https://github.com/ole/whats-new-in-swift-4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;whats-new-in-swift-
    
    </summary>
    
      <category term="iOS" scheme="http://blog.qczyl.club/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>数据驱动的TableView：QCListView_Swift</title>
    <link href="http://blog.qczyl.club/2017/07/27/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84TableView%EF%BC%9AQCListView_Swift/"/>
    <id>http://blog.qczyl.club/2017/07/27/数据驱动的TableView：QCListView_Swift/</id>
    <published>2017-07-27T10:38:33.000Z</published>
    <updated>2017-07-28T01:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>UITableView</code>可以说是iOS开发中最常用的一个控件了，那么对<code>UITableView</code>的使用以及封装就可以说是重中之重了。今天就介绍一个自己封装的由数据进行驱动的<code>UITableView</code>的封装<a href="https://github.com/qcyl/QCListView_Swift" target="_blank" rel="external">QCListView_Swift</a>。</p>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>何为数据驱动？<br>就是只关心数据的处理，数据改变，cell改变。不需要实现<code>UITableView</code>那些繁杂的协议方法。</p>
<p>只是这么说的话，相信大家还都是比较懵的状态，下面看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">// 我需要TableView展示两种cell, 并且每隔一行换一种，我只需要将对应的model拼接成一个数组，</div><div class="line">// 那么UI会自动根据数组中的model找到对应的cell进行展示</div><div class="line"></div><div class="line">class ViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        </div><div class="line">        let tableView = TableView(frame: CGRect(x: 0, y: 0, width: self.view.bounds.width, height: self.view.bounds.height), style: .plain)</div><div class="line">        tableView.qcDataSource = dataSource</div><div class="line">        tableView.qcDelegate = self</div><div class="line">        tableView.register(cell: DemoCell())</div><div class="line">        tableView.register(cell: Demo2Cell())</div><div class="line">        view.addSubview(tableView)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    let dataSource: TableViewDataSource = &#123;</div><div class="line">        let dataSource = TableViewDataSource()</div><div class="line">        </div><div class="line">        var section = SectionObject()</div><div class="line">        section.items = &#123;</div><div class="line">            var items: [TableViewBaseItem] = []</div><div class="line">            </div><div class="line">            for i in 0..&lt;20 &#123;</div><div class="line">                let model = DemoModel()</div><div class="line">                model.count = i</div><div class="line">                items.append(model)</div><div class="line">                let model2 = Demo2Model()</div><div class="line">                model2.count2 = i</div><div class="line">                items.append(model2)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return items</div><div class="line">        &#125;()</div><div class="line">        dataSource.sections = [section]</div><div class="line">        </div><div class="line">        return dataSource</div><div class="line">    &#125;()</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">extension ViewController: TableViewDelegate &#123;</div><div class="line">    func tableView(_ tableView: TableView, didSelectedObject object: TableViewBaseItem, atIndexPath indexPatn: IndexPath) &#123;</div><div class="line">        print(&quot;点击&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>由于<code>UITableView</code>的数据源实际上就是一个二维数组，所以将每组封装成一个<code>SectionObject</code>对象，对象内又包含每行的对象数组<code>items</code>。这样外部按照这个格式来拼接对象就确定了<code>UITableView</code>的数据源。</p>
<p>数据源确定了，还需要确定返回的cell，这里我将每行数据的model与cell之间制定了一个规则（规则说明请看文末），这样就可以通过对应的model找到cell，并返回。</p>
<p>在Model类的父类中<code>TableViewBaseItem</code>，有两个属性<code>cellHeight</code>和<code>itemIdentifier</code>。<code>cellHeight</code>存储cell的高度，在Cell类中实现<code>TableViewCellDelegate</code>协议返回；<code>itemIdentifier</code>根据Model类名转换，并使用这个<code>itemIdentifier</code>注册cell。<br>注：一般情况下，这两个属性都无需关心。</p>
<p>另外<code>UITableView</code>的代理协议中包含非常多的协议方法，<a href="https://github.com/qcyl/QCListView_Swift" target="_blank" rel="external">QCListView_Swift</a>中的<code>TableView</code>不可能将每个协议方法都进行实现，这就需要用到<a href="http://www.olinone.com/?p=643" target="_blank" rel="external">协议分发</a>,通过使用<a href="https://github.com/panghaijiao/HJProtocolDispatcher" target="_blank" rel="external">HJProtocolDispatcher</a>实现协议的分发。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>只需要关心数据的处理，无需每次都实现协议</li>
<li>更好的职责划分，cell的样式，高度由cell内部自己处理</li>
<li>更好的处理多cell的TableView</li>
<li>注册cell时无需区分xib还是class</li>
</ol>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol>
<li><code>SectionObject</code>完善</li>
<li><code>TableViewBaseItem</code>支持泛型处理</li>
<li><code>UITableViewDataSource</code>的协议分发</li>
<li>支持自动高度计算（也有可能不会支持）</li>
</ol>
<h2 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h2><p>本库会自动将Model类（每行对应的对象）后的<code>Model或Item</code>转换成<code>Cell</code>，然后去寻找对应的Cell。</p>
<blockquote>
<p>例如：<br>Model类（DemoModel）会自动去找对应的Cell类（DemoCell）<br>Model类（DemoItem）会自动去找对应的Cell类（DemoCell）</p>
</blockquote>
<p>如果你的个人习惯或者项目要求导致Model类不会以<code>Model或Item</code>结尾，还可创建<code>cellIDRule.plist</code>文件（根结构为数组），在文件内填写需要转换的结尾字符串。</p>
<blockquote>
<p>例如需要转换以<code>Etity</code>结尾的Model类：<br>则在<code>cellIDRule.plist</code>文件中添加一项<code>Etity</code></p>
<p>注意：创建<code>cellIDRule.plist</code>文件后，默认的<code>Model或Item</code>将不再支持</p>
</blockquote>
<hr>
<p>更细致的内容还请大家去看<a href="https://github.com/qcyl/QCListView_Swift" target="_blank" rel="external">demo</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;UITableView&lt;/code&gt;可以说是iOS开发中最常用的一个控件了，那么对&lt;code&gt;UITableView&lt;/code
    
    </summary>
    
      <category term="iOS" scheme="http://blog.qczyl.club/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>多Target、组件化实践</title>
    <link href="http://blog.qczyl.club/2017/07/07/%E5%A4%9ATarget%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.qczyl.club/2017/07/07/多Target、组件化实践/</id>
    <published>2017-07-07T06:49:51.000Z</published>
    <updated>2017-07-07T08:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为公司项目的特性：每个城市对应一个APP，每个APP又有着或多或少的区别；</p>
<p>所以开发人员面临的问题是：开发多个相似APP。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="先说一下之前的解决方案："><a href="#先说一下之前的解决方案：" class="headerlink" title="先说一下之前的解决方案："></a>先说一下之前的解决方案：</h3><p>将所有APP整合为一个大的项目，通过修改配置文件，调用不同APP所需代码。</p>
<p>这样确实是解决了问题，但是方案肯定是不好的。</p>
<p>这样做的缺点：</p>
<ol>
<li>任何一个APP都需要加载所有APP的文件，资源</li>
<li>每次查看不同城市的APP都需要修改配置文件，同时还要修改服务器地址，很容易发生遗漏</li>
<li>所有APP的icon，名称无法单独设置</li>
</ol>
<h3 id="下面是本文的解决方案："><a href="#下面是本文的解决方案：" class="headerlink" title="下面是本文的解决方案："></a>下面是本文的解决方案：</h3><ol>
<li><p>通过Target管理不同城市的APP</p>
<p> <img src="http://ocga9x543.bkt.clouddn.com/WX20170707-113040.png" alt=""></p>
</li>
<li><p>通过cocoapods私有库将项目组件化</p>
<p> 大家可使用<a href="https://github.com/qcyl/module_config" target="_blank" rel="external">cocoapods私有库制作脚本</a>进行私有库制作。更多cocoapods私有库制作请<a href="http://www.jianshu.com/p/0c640821b36f" target="_blank" rel="external">点击</a>。</p>
</li>
<li>不同的Target导入不同的cocoapods私有仓库</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">project <span class="string">'SXC.xcodeproj'</span></div><div class="line"></div><div class="line">platform :ios, <span class="string">'8.0'</span></div><div class="line">use_frameworks!</div><div class="line"></div><div class="line">pod <span class="string">'QCRouter'</span>, :path =&gt; <span class="string">'../QCRouter'</span></div><div class="line"></div><div class="line">target <span class="string">'SXC_GX'</span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Pods for SXC-GX</span></div><div class="line">  pod <span class="string">'SSQ/GX'</span>, :path =&gt; <span class="string">'../SSQ'</span></div><div class="line">  </div><div class="line">end</div><div class="line"></div><div class="line">target <span class="string">'SXC_HLJ'</span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Pods for SXC-HLJ</span></div><div class="line">  pod <span class="string">'SSQ/HLJ'</span>, :path =&gt; <span class="string">'../SSQ'</span></div><div class="line">  </div><div class="line">end</div><div class="line"></div><div class="line">target <span class="string">'SXC_NX'</span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Pods for SXC-NX</span></div><div class="line">  pod <span class="string">'SSQ/NX'</span>, :path =&gt; <span class="string">'../SSQ'</span></div><div class="line">  </div><div class="line">end</div><div class="line"></div><div class="line">target <span class="string">'SXC_TJ'</span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Pods for SXC-TJ</span></div><div class="line">  pod <span class="string">'SSQ/TJ'</span>, :path =&gt; <span class="string">'../SSQ'</span></div><div class="line"></div><div class="line">end</div><div class="line"></div><div class="line">target <span class="string">'SXC_ZJ'</span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Pods for SXC-ZJ</span></div><div class="line">  pod <span class="string">'SSQ/ZJ'</span>, :path =&gt; <span class="string">'../SSQ'</span></div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>多Target使用预定义宏问题</p>
<p> <img src="http://ocga9x543.bkt.clouddn.com/WX20170707-150056.png" alt=""></p>
<p> <img src="http://ocga9x543.bkt.clouddn.com/WX20170707-150127.png" alt=""></p>
<p> 由于本项目为Swift项目，所以如下使用预定义宏</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#if SXC_TJ</div><div class="line">   	let scheme = &quot;sxc-tj&quot;</div><div class="line">#elseif SXC_NX</div><div class="line">    let scheme = &quot;sxc-nx&quot;</div><div class="line">#elseif SXC_GX</div><div class="line">    let scheme = &quot;sxc-gx&quot;</div><div class="line">#elseif SXC_HLJ</div><div class="line">    let scheme = &quot;sxc-hlj&quot;</div><div class="line">#elseif SXC_ZJ</div><div class="line">    let scheme = &quot;sxc-zj&quot;</div><div class="line">#else</div><div class="line">    let scheme = &quot;&quot;</div><div class="line">#endif</div></pre></td></tr></table></figure>
</li>
<li><p>组件化的话，使用了自己开发的<a href="https://github.com/qcyl/QCRouter" target="_blank" rel="external">QCRouter</a>来进行解耦，思路不知道对不对，大家有什么好的建议可以提一下。</p>
</li>
<li><p>创建类的时候要注意选择正确的Target</p>
<p> <img src="http://ocga9x543.bkt.clouddn.com/WX20170707-152510.png" alt=""></p>
</li>
</ol>
<hr>
<p>本文<a href="https://github.com/qcyl/SXC_demo" target="_blank" rel="external">demo</a>地址</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://ibloodline.com/articles/2016/06/16/multiple-targets.html" target="_blank" rel="external">iOS项目中多target的配置</a></li>
<li><a href="http://www.jianshu.com/p/0c640821b36f" target="_blank" rel="external">CocoaPods 私有仓库的创建（超详细）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为公司项目的特性：每个城市对应一个APP，每个APP又有着或多或少的区别；&lt;/p&gt;
&lt;p&gt;所以开发人员面临的问题是：开发多个相似APP。&lt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.qczyl.club/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程和内存管理》读书笔记 GCD篇</title>
    <link href="http://blog.qczyl.club/2017/07/03/%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%20iOS%E4%B8%8EOS%20X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20GCD%E7%AF%87/"/>
    <id>http://blog.qczyl.club/2017/07/03/《Objective-C高级编程 iOS与OS X多线程和内存管理》读书笔记 GCD篇/</id>
    <published>2017-07-03T06:14:08.000Z</published>
    <updated>2017-07-03T06:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要给大家讲解一下GCD的平时不太常用的API，以及文末会贴出GCD定时器的一个小例子。</p>
<h2 id="1-GCD的API"><a href="#1-GCD的API" class="headerlink" title="1.GCD的API"></a>1.GCD的API</h2><h3 id="1-1-Dispatch-Queue"><a href="#1-1-Dispatch-Queue" class="headerlink" title="1.1 Dispatch Queue"></a>1.1 Dispatch Queue</h3><p>要谈GCD，就一定要了解<code>Dispatch Queue</code>（执行处理的等待队列）。<br><code>Dispatch Queue</code>按照追加的顺序（先进先出FIFO，First-In-First-Out）执行处理。<br>另外在执行处理是存在两种<code>Dispatch Queue</code>，一种是等待现在执行中处理的<code>Serial Dispatch Queue</code>，另一种是不等待现在执行中处理的<code>Concurrent Dispatch Queue</code>。</p>
<p><img src="http://ocga9x543.bkt.clouddn.com/WX20170703-111143.png" alt=""></p>
<h3 id="1-2-dispatch-queue-create"><a href="#1-2-dispatch-queue-create" class="headerlink" title="1.2 dispatch_queue_create"></a>1.2 dispatch_queue_create</h3><p>由于平时在使用时，我们大部分都是使用系统提供的<code>Main Dispatch Queue</code>和<code>Global Dispatch Queue</code>。<br>所以关于<code>dispatch_queue_create</code>API，这里只说两点：</p>
<ul>
<li>通过<code>dispatch_queue_create</code>函数生成的<code>Dispatch Queue</code>在使用结束后要通过<code>dispatch_release</code>函数释放。</li>
<li>如果生成过多的线程，就会消耗大量内存，大幅度降低系统的响应性能。而使用系统提供的<code>Global Dispatch Queue</code>则不用担心这个问题。所以除非必要，其他情况建议使用系统提供的<code>Dispatch Queue</code>。</li>
</ul>
<h3 id="1-3-dispatch-set-target-queue"><a href="#1-3-dispatch-set-target-queue" class="headerlink" title="1.3 dispatch_set_target_queue"></a>1.3 dispatch_set_target_queue</h3><p>使用<code>dispatch_queue_create</code>函数生成的<code>Dispatch Queue</code>，都使用的是与系统提供的<code>Global Dispatch Queue</code>的默认优先级相同的优先级。而要变更生成的执行优先级的话就要使用<code>dispatch_set_target_queue</code>函数。</p>
<p>在后台执行动作处理的<code>Serial Dispatch Queue</code>的生成方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(&quot;com.example.gcd.mySerialDispatchQueue&quot;, NULL);</div><div class="line">   dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</div><div class="line">   dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</div></pre></td></tr></table></figure>
<h3 id="1-3-dispatch-after"><a href="#1-3-dispatch-after" class="headerlink" title="1.3 dispatch_after"></a>1.3 dispatch_after</h3><p><code>dispatch_after</code>这里只说一点，<code>dispatch_after</code>函数并不是在指定时间后执行处理，而只是在指定时间追加处理到<code>Dispatch Queue</code>。</p>
<p>因为<code>Main Dispatch Queue</code>在主线程的<code>RunLoop</code>中执行，所以在比如每隔1/60秒执行的<code>RunLoop</code>中，Block最快在 3 秒后执行，最慢在 3 秒 + 1/60 秒后执行，并且在<code>Main Dispatch Queue</code>有大量处理追加或主线程的处理本身有延迟时，这个时间会更长。</p>
<p>所以该函数在有严格时间要求的情况下使用会出现问题，但是只是想大致延迟执行处理，该函数是非常有效的。</p>
<h3 id="1-4-dispatch-barrier-async"><a href="#1-4-dispatch-barrier-async" class="headerlink" title="1.4 dispatch_barrier_async"></a>1.4 dispatch_barrier_async</h3><p>在访问数据库或文件时，使用多线程可能会产生数据竞争的问题，当然使用<code>Serial Dispatch Queue</code>可避免数据竞争。</p>
<p>但是如果读取处理只是与读取处理并行执行，那么多个并行执行就不会发生问题。也就是说为了高效率的进行访问，读取处理追加到<code>Concurrent Dispatch Queue</code>，写入处理在任一读取处理没有执行的状态下，追加到<code>Serial Dispatch Queue</code>中即可（在写入处理结束之前，读取处理不可执行）。</p>
<p>使用<code>dispatch_barrier_async</code>便可解决这个问题。<code>dispatch_barrier_async</code>函数会等待追加到<code>Concurrent Dispatch Queue</code>上的并行执行的处理全部结束后，再将制定的处理追加到该<code>Concurrent Dispatch Queue</code>中。然后在由<code>dispatch_barrier_async</code>函数追加的处理执行完毕后，<code>Concurrent Dispatch Queue</code>才恢复为一般的动作，追加到该<code>Concurrent Dispatch Queue</code>的处理又开始并行执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_async(queue, blk0_for_reading);</div><div class="line">dispatch_async(queue, blk1_for_reading);</div><div class="line">dispatch_async(queue, blk2_for_reading);</div><div class="line">dispatch_async(queue, blk3_for_reading);</div><div class="line">dispatch_barrier_async(queue, blk_for_writing);</div><div class="line">dispatch_async(queue, blk4_for_reading);</div><div class="line">dispatch_async(queue, blk5_for_reading);</div><div class="line">dispatch_async(queue, blk6_for_reading);</div><div class="line">dispatch_async(queue, blk7_for_reading);</div></pre></td></tr></table></figure>
<p>如上所示，使用方法非常简单。仅使用<code>dispatch_barrier_async</code>函数代替<code>dispatch_async</code>函数即可。</p>
<p><img src="http://ocga9x543.bkt.clouddn.com/WX20170703-115939.png" alt=""></p>
<h3 id="1-5-dispatch-apply"><a href="#1-5-dispatch-apply" class="headerlink" title="1.5 dispatch_apply"></a>1.5 dispatch_apply</h3><p><code>dispatch_apply</code>函数是<code>dispatch_sync</code>函数和<code>Dispatch Group</code>的关联API。该函数按指定的次数将指定的Block追加到指定的<code>Dispatch Queue</code>中，并等待全部处理执行结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_apply(10, queue, ^(size_t index) &#123;</div><div class="line">    NSLog(@&quot;%zu&quot;, index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;done&quot;);</div></pre></td></tr></table></figure>
<p>例如，该源代码的执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line">1</div><div class="line">0</div><div class="line">3</div><div class="line">5</div><div class="line">2</div><div class="line">6</div><div class="line">8</div><div class="line">9</div><div class="line">7</div><div class="line">done</div></pre></td></tr></table></figure>
<p>因为在<code>Global Dispatch Queue</code>中执行处理，所以各个处理的执行时间不定。但是输出结果中最后的done必定在最后的位置上。这是因为<code>dispatch_apply</code>函数会等待全部处理执行结束。</p>
<h3 id="1-6-Dispatch-I-O"><a href="#1-6-Dispatch-I-O" class="headerlink" title="1.6 Dispatch I/O"></a>1.6 Dispatch I/O</h3><p>大家可能想过，在读取较大文件时，如果将文件分成合适的大小并使用<code>Global Dispatch Queue</code>并列读取的话，应该会比一般的读取速度快不少。能实现这一功能的就是<code>Dispatch I/O</code>和<code>Dispatch Data</code>。</p>
<p><img src="http://ocga9x543.bkt.clouddn.com/WX20170703-140234.png" alt=""></p>
<p>如果想提高文件读取速度，可以尝试使用<code>Dispatch I/O</code>。</p>
<h3 id="1-7-Dispatch-Source"><a href="#1-7-Dispatch-Source" class="headerlink" title="1.7 Dispatch Source"></a>1.7 Dispatch Source</h3><p>GCD中出了主要的<code>Dispatch Queue</code>外，还有不太引人注目的<code>Dispatch Source</code>。它是BSD系内核惯有功能<code>kqueue</code>的包装。<br><code>kqueue</code>是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷非常小，尽量不占用资源。<code>kqueue</code>可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种。</p>
<p><code>Dispatch Source</code>可以处理一下事件。</p>
<p><img src="http://ocga9x543.bkt.clouddn.com/WX20170703-141244.png" alt=""></p>
<p>在使用NSTimer做定时器的时候，大家应该都知道如果使用不当，会出现内存泄漏的问题。<br>而如果作为一个封装的组件来说，就需要将NSTimer属性暴露出来，在控制器销毁时，调用NSTimer的invalidate方法。如果忘记的话就会内存泄漏！</p>
<p>但是使用<code>DISPATCH_SOUTCE_TYPE_TIMER</code>的话就不需要担心这个问题了。</p>
<p><a href="https://github.com/qcyl/GCD-Timer-Demo" target="_blank" rel="external">此处</a>为使用了<code>DISPATCH_SOUTCE_TYPE_TIMER</code>的定时器的小demo。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要给大家讲解一下GCD的平时不太常用的API，以及文末会贴出GCD定时器的一个小例子。&lt;/p&gt;
&lt;h2 id=&quot;1-GCD的API&quot;&gt;&lt;a href=&quot;#1-GCD的API&quot; class=&quot;headerlink&quot; title=&quot;1.GCD的API&quot;&gt;&lt;/a&gt;1.G
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.qczyl.club/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程和内存管理》读书笔记 Block篇</title>
    <link href="http://blog.qczyl.club/2017/06/29/%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%20iOS%E4%B8%8EOS%20X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20Block%E7%AF%87/"/>
    <id>http://blog.qczyl.club/2017/06/29/《Objective-C高级编程 iOS与OS X多线程和内存管理》读书笔记 Block篇/</id>
    <published>2017-06-28T16:00:00.000Z</published>
    <updated>2017-06-30T08:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于block部分内容还是比较多的，如果全部都细讲的话，篇幅会非常的长。强烈建议大家去看<a href="https://item.jd.com/11258970.html" target="_blank" rel="external">本书</a>（<a href="https://pan.baidu.com/s/1jHNOboq" target="_blank" rel="external">PDF版</a>）。</p>
<p>所以本文重点讲述 <strong>Block存储域</strong> 部分的内容。</p>
<h2 id="1-Block的实质"><a href="#1-Block的实质" class="headerlink" title="1.Block的实质"></a>1.Block的实质</h2><blockquote>
<p>要说各种Block相关内容的话，一定要先了解Block的实质。</p>
</blockquote>
<p>首先，我们通过<a href="https://zh.wikipedia.org/wiki/Clang" target="_blank" rel="external">clang</a>转换Block语法。(源码太多，所以截图，请见谅)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-4d74e021c947bec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>此源码的Block语法最为简单，该源码通过<a href="https://zh.wikipedia.org/wiki/Clang" target="_blank" rel="external">clang</a>可变换为以下形式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-1a4dec8ed13c898e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们目前需要重点关心的为红色圈出的部分。</p>
<h2 id="2-Block存储域"><a href="#2-Block存储域" class="headerlink" title="2.Block存储域"></a>2.Block存储域</h2><p><img src="http://upload-images.jianshu.io/upload_images/1787055-92df46c39f580f29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上述源码通过<code>impl.isa = &amp;_NSConcreteStackBlcok;</code>我们可以看出，该Block的类为_NSConcreteStackBlcok，设置在栈上。</p>
<p>下面我们再来看看设置在数据区域的Block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^blk)(void) = ^&#123;printf(&quot;Global Block\n&quot;);&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div></pre></td></tr></table></figure>
<p>此源代码通过声明全局变量blk来使用Block语法。如果转换该源代码，Block用结构体的成员变量isa的初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">impl.isa = &amp;_NSConcreteGlobalBlcok;</div></pre></td></tr></table></figure>
<p>该Block的类为_NSConcreteGlobalBlcok类。因为在使用全局变量的地方不能使用自动变量没所以不存在对自动变量进行截获。</p>
<p>所以只要Block不截获自动变量，就可以将Block用结构体实例设置在程序的数据区域。</p>
<p>配置在全局变量上的Block，从变量作用域外也可以通过指针安全的使用。但设置在栈上的Block，如果其所属的变量作用于结束，该Block就被废弃。由于<strong>blcok变量也配置在栈上，同样的，如果其所属的作用域结束，则该</strong>block变量也会被废弃。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-9dc8a736878353ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Block提供了将Block和__block变量从栈上复制到堆上的方法来解决这个问题。将配置在栈上的Block复制到堆上，这样即使Block语法所属的变量作用域结束，堆上的Block还可以继续存在。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-355a3424f29d8f22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>复制到堆上的Block将_NSConcreteMallocBlcok类对象写入Block用结构体实例的成员变量isa。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">impl.isa = &amp; _NSConcreteMallocBlcok;</div></pre></td></tr></table></figure>
<p>那么Blcok提供的复制方法究竟是什么呢？实际上当ARC有效时，大多数情形下编译器会恰当地进行判断，自动生成将Block从栈上复制到堆上的代码。</p>
<p>例如：将Blcok作为函数返回值返回时，编译器会自动生成复制到堆上的代码。</p>
<p>前面讲到过“大多数情况下编译器会恰当地进行判断”，不过在此之外的情况下需要手动生成代码，将Block从栈上复制到堆上。此时我们使用“copy实例方法”。那么编译器不能进行判断的究竟是什么样的状况呢？如下所示：</p>
<ul>
<li>向方法或函数的参数中传递Block时</li>
</ul>
<p>但是如果在方法或函数中恰当地复制了传递过来的参数，那么就不必再调用该方法或函数前手动复制了。以下方法或函数不用手动复制。</p>
<ul>
<li>Cocoa框架的方法且方法名中含有usingBlock等时</li>
<li>GCD的API</li>
</ul>
<p>举个具体例子，在使用NSArray类的enumerateObjectsUsingBlock实例方法以及dispatch_async函数时，不用手动复制。相反地，在NSArray类的initWithObjects实例方法上传递Block时需要手动复制。下面我们来看看源代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)getBlockArray </div><div class="line">&#123;</div><div class="line">	int val = 10;</div><div class="line">	return [[NSArray alloc] initWithObjects:</div><div class="line">			^&#123;NSLog(@&quot;blk0:%d&quot;, val)&#125;,</div><div class="line">			^&#123;NSLog(@&quot;blk1:%d&quot;, val)&#125;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getBlockArray方法在栈上生成两个Block，并传递给NSArray类的initWithObjects实例方法。下面，在getBlockArray方法调用方，从NSArray对象中取出Block并执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id obj = getBlockArray();</div><div class="line">typedef void (^blk_t)(void);</div><div class="line">blk_t blk = (blk_t)[obj objectAtIndex:0];</div><div class="line">blk();</div></pre></td></tr></table></figure>
<p>该源代码的blk()，即Block在执行时发生异常，应用程序强制结束。这是由于在getBlockArray函数执行结束时，栈上的Block被废弃的缘故。可惜此时编译器不能判断是否需要复制。也可以不让编译器进行判断，而使其在所有情况下都能复制。但将Block从栈上复制到堆上是相当消耗CPU的。当Block设置在栈上也能使用时，将Block从栈上复制到堆上只是在浪费CPU资源。因此只在此情形下让编程人员手动进行复制。</p>
<p>该源代码像下面这样修改一下即可正常运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	int val = 10;</div><div class="line">	return [[NSArray alloc] initWithObjects:</div><div class="line">			[^&#123;NSLog(@&quot;blk0:%d&quot;, val)&#125; copy],</div><div class="line">			[^&#123;NSLog(@&quot;blk1:%d&quot;, val)&#125; copy], nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，对于已配置在堆上的Block以及配置在程序的数据区域上的Blcok，调用copy方法又会如何呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-d05dc12aae560c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>不管Block配置在何处，用copy方法复制都不会引起任何问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于block部分内容还是比较多的，如果全部都细讲的话，篇幅会非常的长。强烈建议大家去看&lt;a href=&quot;https://item.jd.com/11258970.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本书&lt;/a&gt;（&lt;a href=&quot;ht
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.qczyl.club/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程和内存管理》读书笔记 自动引用计数篇</title>
    <link href="http://blog.qczyl.club/2017/06/28/%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%20iOS%E4%B8%8EOS%20X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AF%87/"/>
    <id>http://blog.qczyl.club/2017/06/28/《Objective-C高级编程 iOS与OS X多线程和内存管理》读书笔记 自动引用计数篇/</id>
    <published>2017-06-27T17:00:00.000Z</published>
    <updated>2017-06-30T08:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p>顾名思义，自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对引用采取自动计数的技术。以下摘自苹果的官方说明。</p>
<p>在Objective-C 中采用Automatic Reference Counting（ARC）机制，让编译器来进行内存管理。在新一代Apple LLVM 编译器中设置ARC 为有效状态，就无需再次键入retain 或者release 代码，这在降低程序崩溃、内存泄漏等风险的同时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不再被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。</p>
</blockquote>
<h3 id="一、内存管理的思考方式"><a href="#一、内存管理的思考方式" class="headerlink" title="一、内存管理的思考方式"></a>一、内存管理的思考方式</h3><blockquote>
<p>看到”引用计数”这个名称，我们便会不自觉地联想到”某处有某物多少多少”而将注意力放到计数上。但其实，更加客观、正确的思考方式是：</p>
<ul>
<li>自己生成的对象，自己所持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要 自己持有的对象 时释放。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
</blockquote>
<h5 id="1-自己生成的对象，自己所持有"><a href="#1-自己生成的对象，自己所持有" class="headerlink" title="1. 自己生成的对象，自己所持有"></a>1. 自己生成的对象，自己所持有</h5><p>使用”以下名称开头”的方法名意味着自己生成的对象只有自己持有：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>注：”以下名称开头”包括 allocMyObject，但不包括 allocmyobject，需要遵循驼峰式命名规范</p>
<h5 id="2-非自己生成的对象，自己也能持有"><a href="#2-非自己生成的对象，自己也能持有" class="headerlink" title="2. 非自己生成的对象，自己也能持有"></a>2. 非自己生成的对象，自己也能持有</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">例：</div><div class="line">    // 取得非自己生成的对象</div><div class="line">    id obj = [NSMutableArray array];</div><div class="line">    // 自己持有</div><div class="line">    [obj retain];</div></pre></td></tr></table></figure>
<p>注：一般情况下，调用这类方法无需自己持有，在NSMutableArray的array方法中，<br>已将生成的对象注册到了自动释放池，所以无需obj持有也不会释放（注释为个人理解，如有错误请指出）</p>
<h5 id="3-不再需要-自己持有对象-时释放"><a href="#3-不再需要-自己持有对象-时释放" class="headerlink" title="3. 不再需要 自己持有对象 时释放"></a>3. 不再需要 自己持有对象 时释放</h5><p>用 alloc/new/copy/mutableCopy “开头”的方法生成并持有的对象，或者用 retain 方法持有的对象，一旦不再需要，务必要用release方法进行释放。</p>
<h5 id="4-非自己持有的对象无法释放"><a href="#4-非自己持有的对象无法释放" class="headerlink" title="4. 非自己持有的对象无法释放"></a>4. 非自己持有的对象无法释放</h5><p>对于用alloc/new/copy/mutableCopy 方法生成并持有的对象，<br>或是用retain方法持有的对象，由于持有者是自己，所以在不需要该对象时需要将其释放。<br>而由此以外所得到的对象绝对不能释放。倘若在应用程序中释放了非自己所持有的对象就会造成崩溃。</p>
<h3 id="二、ARC（重点）"><a href="#二、ARC（重点）" class="headerlink" title="二、ARC（重点）"></a>二、ARC（重点）</h3><blockquote>
<p>“引用计数式内存管理”的本质部分在ARC中并没有改变。就像”自动引用计数”这个名称表示的那样，ARC只是自动的帮助我们处理”引用计数”的相关部分</p>
</blockquote>
<h4 id="2-1-所有权修饰符"><a href="#2-1-所有权修饰符" class="headerlink" title="2.1 所有权修饰符"></a>2.1 所有权修饰符</h4><ul>
<li>__strong修饰符</li>
<li>__weak修饰符</li>
<li>__unsafe_unretained修饰符</li>
<li>__autoreleasing修饰符</li>
</ul>
<h5 id="2-1-1-strong修饰符"><a href="#2-1-1-strong修饰符" class="headerlink" title="2.1.1 __strong修饰符"></a>2.1.1 __strong修饰符</h5><p>__strong修饰符是id类型和对象类型默认的所有权修饰符。<br>如”strong”这个名称所示，__strong修饰符表示对对象的”强引用”(持有对象)。<br>持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    /*</div><div class="line">     *  自己生成并持有对象</div><div class="line">     */</div><div class="line">    id __strong obj = [[NSObject alloc] init];</div><div class="line">    /*</div><div class="line">     *  因为变量obj为强引用，</div><div class="line">     *  所以自己持有对象</div><div class="line">     */</div><div class="line">&#125;</div><div class="line">    /*</div><div class="line">     *  因为变量obj超出其作用域，强引用失效，</div><div class="line">     *  所以自动的释放自己持有的对象。</div><div class="line">     *  对象的所有者不存在，因此废弃该对象。</div><div class="line">     */</div></pre></td></tr></table></figure>
<h5 id="2-1-2-weak修饰符"><a href="#2-1-2-weak修饰符" class="headerlink" title="2.1.2 __weak修饰符"></a>2.1.2 __weak修饰符</h5><p>大家应该都知道，如果只是用__strong修饰符的话必然会发生”循环引用”的问题。<br>而__weak修饰符就可以避免这一问题。<br>__weak修饰符与__strong修饰符相反，提供”弱引用”(不持有对象)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    /*</div><div class="line">     *  自己生成并持有对象</div><div class="line">     */</div><div class="line">    id __strong obj0 = [[NSObject alloc] init];</div><div class="line">    /*</div><div class="line">     *  因为变量obj为强引用，</div><div class="line">     *  所以自己持有对象</div><div class="line">     */</div><div class="line">    id __weak obj1 = obj0;</div><div class="line">    /*</div><div class="line">     *  obj1变量持有生成对象的弱引用</div><div class="line">     */</div><div class="line">&#125;</div><div class="line">    /*</div><div class="line">     *  因为变量obj0超出其作用域，强引用失效，</div><div class="line">     *  所以自动的释放自己持有的对象。</div><div class="line">     *  对象的所有者不存在，因此废弃该对象。</div><div class="line">     */</div></pre></td></tr></table></figure>
<p>__weak修饰符还有一个优点。在持有某对象的弱引用时，<br>若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态。</p>
<h5 id="2-1-3-unsafe-unretained修饰符（很少使用）"><a href="#2-1-3-unsafe-unretained修饰符（很少使用）" class="headerlink" title="2.1.3 __unsafe_unretained修饰符（很少使用）"></a>2.1.3 __unsafe_unretained修饰符（很少使用）</h5><p>__unsafe_unretained修饰符正如其名unsafe所示，是不安全的所有权修饰符。<br>尽管ARC式的内存管理是编译器的工作，但附有__unsafe_unretained修饰符<br>的变量不属于编译器的内存管理对象。这一点在使用时要注意。<br>附有__unsafe_unretained修饰符的变量同附有__weak修饰符的变量一样，<br>因为自己生成并持有的对象不能继续为自己所用，所以生成的对象会立即被释放。</p>
<p>注：__unsafe_unretained修饰符在对象被废弃时不会主动赋值nil，所以会访问到”悬垂指针”，导致系统在个别运行情况下崩溃。</p>
<h5 id="2-1-4-autoreleasing修饰符（虽然很少显式附加，但很多情况下都会使用，所以很重要）"><a href="#2-1-4-autoreleasing修饰符（虽然很少显式附加，但很多情况下都会使用，所以很重要）" class="headerlink" title="2.1.4 __autoreleasing修饰符（虽然很少显式附加，但很多情况下都会使用，所以很重要）"></a>2.1.4 __autoreleasing修饰符（虽然很少显式附加，但很多情况下都会使用，所以很重要）</h5><p>ARC无效时会像下面这样来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* ARC无效 */</div><div class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</div><div class="line">id obj = [[NSObject alloc] init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];</div></pre></td></tr></table></figure>
<p>ARC有效时，该源码也能写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    id __autoreleasing obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，显式的附加__autoreleasing修饰符同显式的附加__strong修饰符一样罕见。</p>
<p>我们通过实例来看看为什么非显式地使用__autoreleasing修饰符也可以。</p>
<p>1、编译器会检查方法名是否以alloc/new/copy/mutableCopy 开始，<br>如果不是则自动将返回值的对象注册到autoreleasepool。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;  </div><div class="line">/*  </div><div class="line"> * 取得非自己生成并持有的对象  </div><div class="line"> */  </div><div class="line">id __strong obj = [NSMutableArray array];  </div><div class="line">/*  </div><div class="line"> * 因为变量obj 为强引用，  </div><div class="line"> * 所以自己持有对象。  </div><div class="line"> *  </div><div class="line"> * 并且该对象  </div><div class="line"> * 由编译器判断其方法名后  </div><div class="line"> * 自动注册到autoreleasepool  </div><div class="line"> */  </div><div class="line">&#125; </div><div class="line">/*  </div><div class="line"> * 因为变量obj 超出其作用域，强引用失效，  </div><div class="line"> * 所以自动释放自己持有的对象。  </div><div class="line"> *  </div><div class="line"> * 同时，随着@autoreleasepool 块的结束，  </div><div class="line"> * 注册到autoreleasepool 中的  </div><div class="line"> * 所有对象被自动释放。  </div><div class="line"> *  </div><div class="line"> * 因为对象的所有者不存在，所以废弃对象。  </div><div class="line"> */</div></pre></td></tr></table></figure>
<p>2、由于return使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，<br>但该对象作为函数的返回值，编译器会自动将其注册到autoreleasepool。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (id) array  </div><div class="line">&#123;  </div><div class="line">	id obj = [[NSMutableArray alloc] init];  </div><div class="line">	return obj;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、以下为使用__weak修饰符的例子。虽然__weak修饰符是为了避免循环引用而使用的，<br>但在访问附有__weak修饰符的变量时，实际上必定要访问注册到autoreleasepool的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;  </div><div class="line">NSLog(@&quot;class=%@&quot;, [obj1 class]);</div></pre></td></tr></table></figure>
<p>以下源代码与此相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;  </div><div class="line">id __autoreleasing tmp = obj1;  </div><div class="line">NSLog(@&quot;class=%@&quot;, [tmp class]);</div></pre></td></tr></table></figure>
<p>为什么在访问附有__weak修饰符的变量时必须访问注册到autoreleasepool 的对象呢？<br>这是因为__weak修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。<br>如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。<br>因此，在使用附有__weak修饰符的变量时就必定要使用注册到autoreleasepool中的对象。</p>
<p>4、最后一个可非显式地使用__autoreleasing修饰符的例子，同前面讲述的id obj 和id __strongobj 完全一样。</p>
<p>那么id 的指针id <em>obj 又如何呢？可以由id __strong obj 的例子类推出id __strong</em>obj 吗？</p>
<p>其实，推出来的是id __autoreleasing <em>obj。<br>同样地，对象的指针NSObject **obj 便成为了NSObject </em> __autoreleasing *obj。<br>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL) performOperationWithError:(NSError **)error;</div></pre></td></tr></table></figure>
<p>同前面讲述的一样，id的指针或对象的指针会默认附加上__autoreleasing 修饰符，所以等同于以下源代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL) performOperationWithError:(NSError * __autoreleasing *)error;</div></pre></td></tr></table></figure>
<p>下面的源代码会产生编译器错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;  </div><div class="line">NSError **pError = &amp;error; </div><div class="line">赋值给对象指针时，所有权修饰符必须一致。</div><div class="line">error: initializing &apos;NSError *__autoreleasing *&apos; with an expression  </div><div class="line">of type &apos;NSError *__strong *&apos; changes retain/release properties of pointer  </div><div class="line">NSError **pError = &amp;error;  </div><div class="line">        ^           ~~~~~~ </div><div class="line">此时，对象指针必须附加__strong 修饰符。</div><div class="line">NSError *error = nil;  </div><div class="line">NSError * __strong *pError = &amp;error;  </div><div class="line">/* 编译正常 */</div></pre></td></tr></table></figure>
<h4 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h4><p><img src="http://upload\-images.jianshu.io/upload\_images/1787055\-83eef1a8a0494bb1.jpg?imageMogr2/auto\-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.如何防止block的内存泄漏？ </p>
<ul>
<li>答：使用__weak将self弱引用</li>
</ul>
<p>2.那为什么又要在block中将self使用__strong强引用呢？</p>
<ul>
<li>答案一：防止self在使用过程中被释放掉。（未读本书前的理解）</li>
<li>答案二：既然使用__weak修饰的变量在使用时会自动加入到自动释放池，就保证了在使用过程中不会被释放掉。同时，由于使用__weak修饰的变量在每次使用时都会加入到一个自动释放池中，所以会消耗资源，但是使用__strong强引用一下就不会了。（读本书后的理解，不知道对不对，希望各位大神指点一下）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语：&quot;&gt;&lt;a href=&quot;#导语：&quot; class=&quot;headerlink&quot; title=&quot;导语：&quot;&gt;&lt;/a&gt;导语：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;顾名思义，自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.qczyl.club/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub Pages搭建个人博客</title>
    <link href="http://blog.qczyl.club/2017/06/28/Hexo+GitHub%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://blog.qczyl.club/2017/06/28/Hexo+GitHub Pages搭建个人博客/</id>
    <published>2017-06-27T16:00:00.000Z</published>
    <updated>2017-06-30T08:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录自己在搭建个人博客的记录，以及工程中遇到的一些问题。</p>
<p>废话少说，上干货。</p>
<h4 id="1-GitHub仓库"><a href="#1-GitHub仓库" class="headerlink" title="1. GitHub仓库"></a>1. GitHub仓库</h4><p>由于本博客的搭建是基于Hexo + GitHub Page的，所以GitHub账号是必不可少的。<br>相信大家应该也都有自己的账号了，没有的赶紧去注册一个吧！</p>
<p>注：账号的username会影响你的域名哦！</p>
<p>我们需要创建一个仓库来存储我们的博客内容，点击首页任意位置出现的<code>New repository</code>按钮创建仓库，Respository name中的<code>username</code>.github.io的<code>username</code>一定与前面的Owner 一致。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-137e556b3f8107e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建仓库"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-b664fcba6dbd2869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要保持username一致"></p>
<h4 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h4><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<h6 id="2-1-安装brew（如果已安装，请忽略）"><a href="#2-1-安装brew（如果已安装，请忽略）" class="headerlink" title="2.1 安装brew（如果已安装，请忽略）"></a>2.1 安装brew（如果已安装，请忽略）</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ /usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></div></pre></td></tr></table></figure>
<h6 id="2-2-安装git"><a href="#2-2-安装git" class="headerlink" title="2.2 安装git"></a>2.2 安装git</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install git</div></pre></td></tr></table></figure>
<h6 id="2-3-安装nodejs"><a href="#2-3-安装nodejs" class="headerlink" title="2.3 安装nodejs"></a>2.3 安装nodejs</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用brew安装nvm</span></div><div class="line">$ brew install nvm</div><div class="line"></div><div class="line"><span class="comment"># vim ~/.bash_profile后增加下面这两行</span></div><div class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></div><div class="line"><span class="built_in">source</span> $(brew --prefix nvm)/nvm.sh</div><div class="line"></div><div class="line"><span class="comment"># .bash_profile立即生效</span></div><div class="line">$ <span class="built_in">source</span> ~/.bash_profile</div><div class="line"></div><div class="line"><span class="comment"># 使用nvm安装node.js</span></div><div class="line">$ nvm install node</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 校验（建议重启终端后校验）</span></div><div class="line">$ nvm --version</div><div class="line">0.33.2</div><div class="line">$ node -v</div><div class="line">v8.1.2</div><div class="line">$ npm -v</div><div class="line">5.0.3</div><div class="line">$ nvm list</div><div class="line">-&gt;       v8.1.2</div><div class="line">default -&gt; node (-&gt; v8.1.2)</div><div class="line">node -&gt; stable (-&gt; v8.1.2) (default)</div><div class="line">stable -&gt; 8.1 (-&gt; v8.1.2) (default)</div><div class="line">iojs -&gt; N/A (default)</div><div class="line">lts/* -&gt; lts/boron (-&gt; N/A)</div><div class="line">lts/argon -&gt; v4.8.3 (-&gt; N/A)</div><div class="line">lts/boron -&gt; v6.11.0 (-&gt; N/A)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">如果校验成功，可忽略此步骤！</div><div class="line">如果校验失败，则有很大的可能是本地的node，nvm，npm版本出现问题。</div><div class="line">可尝试一下方法解决：</div><div class="line">1、卸载老版本的node</div><div class="line">    如果是从brew安装的, 运行brew uninstall node</div><div class="line">    删除~/目录下所有node和node_modules</div><div class="line">    删除/usr/local/lib中的所有node和node_modules</div><div class="line">    删除/usr/local/lib中的所有node和node_modules的文件夹</div><div class="line">    在/usr/local/bin中,删除所有node的可执行文件(node和npm)</div><div class="line">    </div><div class="line">    手动删除文件，整理成脚本是这个样子:</div><div class="line">    sudo rm -rf ~/.npm</div><div class="line">    sudo rm -rf ~/node_modules</div><div class="line">    sudo rm -rf ~/.node-gyp</div><div class="line">    sudo rm /usr/local/bin/node</div><div class="line">    sudo rm /usr/local/bin/npm</div><div class="line">    sudo rm /usr/local/lib/dtrace/node.d</div><div class="line"></div><div class="line">2、卸载老版本.nvm</div><div class="line">    我之前是手动安装的nvm，nvm的目录结构比较简单，删除这三个就可以了</div><div class="line">    # 删除后请确认删除干净了</div><div class="line">    rm -rf ~/.nvm</div><div class="line">    rm -rf ~/.npm</div><div class="line">    rm -rf ~/.bower</div><div class="line">    </div><div class="line">    还需要删除下.bash_profile文件中的配置(用brew安装后还需要重新加上，但不太一样)</div><div class="line">    export NVM_DIR=&quot;$HOME/.nvm&quot;</div><div class="line">    source $(brew --prefix nvm)/nvm.sh</div><div class="line"></div><div class="line">3、清除干净后确认(重启终端后测试)</div><div class="line">    &quot;重启终端&quot;后，挨个测试几个命令应该都是找不到，才算是正确的:</div><div class="line">    nvm</div><div class="line">    node</div><div class="line">    npm</div><div class="line">    </div><div class="line">4、重新从 2.3安装nodejs 开始执行</div></pre></td></tr></table></figure>
<h6 id="2-4-安装Hexo"><a href="#2-4-安装Hexo" class="headerlink" title="2.4 安装Hexo"></a>2.4 安装Hexo</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo --no-optional</div><div class="line"><span class="comment"># 安装hexo-deployer-git自动部署发布工具</span></div><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装Hexo时，不添加--no-optional可能会报如下错误，但不影响使用，建议添加</span></div><div class="line">&#123; [Error: Cannot find module <span class="string">'./build/Release/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div><div class="line">&#123; [Error: Cannot find module <span class="string">'./build/default/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div><div class="line">&#123; [Error: Cannot find module <span class="string">'./build/Debug/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div><div class="line"></div><div class="line"><span class="comment"># 如果添加--no-optional仍报上述错误的话，可以尝试下面的方法，重装 hexo-cli</span></div><div class="line">$ npm uninstall hexo-cli -g</div><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>所有必须工具已经安装完成，下面我们就可以生成博客，上传至我们的Github 仓库了。</p>
<h4 id="3-编写，发布"><a href="#3-编写，发布" class="headerlink" title="3. 编写，发布"></a>3. 编写，发布</h4><blockquote>
<p>接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(username.github.io)。</p>
</blockquote>
<h6 id="3-1-创建博客"><a href="#3-1-创建博客" class="headerlink" title="3.1 创建博客"></a>3.1 创建博客</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 执行成功后，会在当前目录下创建出一个名为 blog 的文件夹。</div><div class="line">$ hexo init blog</div></pre></td></tr></table></figure>
<h6 id="3-2-更改配置"><a href="#3-2-更改配置" class="headerlink" title="3.2 更改配置"></a>3.2 更改配置</h6><p>1.主题安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 为了使博客不太难看，我们需要安装一个主题，切换至刚刚生成的blog目录，安装主题</span></div><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<p>这里有<a href="https://hexo.io/themes/" target="_blank" rel="external">更多主题</a>供你选择。喵神的主题在<a href="https://github.com/monniya/hexo-theme-new-vno" target="_blank" rel="external">这里</a>。</p>
<p>2.基础配置:</p>
<p>打开文件位置blog/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">更多设置</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">title: qczyl&apos;s club     //你博客的名字</div><div class="line">author: qczyl           //你的名字</div><div class="line">language: zh-Hans       //语言 中文</div><div class="line">theme: next             //刚刚安装的主题名称</div><div class="line">deploy:</div><div class="line">  type: git             //使用Git 发布</div><div class="line">  repo: https://github.com/qcyl/qcyl.github.io.git    // 刚创建的Github仓库</div></pre></td></tr></table></figure>
<p>3.主题配置:</p>
<p>主题配置文件在blog/themes/next/_config.yml中修改，这里略过。<a href="http://theme-next.iissnan.com/getting-started.html#theme-settings" target="_blank" rel="external">设置详情</a></p>
<h6 id="3-3-写文章"><a href="#3-3-写文章" class="headerlink" title="3.3 写文章"></a>3.3 写文章</h6><p>所有基础框架都已经创建完成，接下来可以开始写你的第一篇博客了。<br>在blog/source/_posts下创建你的第一个博客吧，<br>例如，创建一个名为FirstNight.md的文件，用Markdown大肆发挥吧，注意保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">---</div><div class="line">title: First Night</div><div class="line">---</div><div class="line">&gt; 我有一头**小毛驴**，可是我从来都不骑。</div></pre></td></tr></table></figure>
<h6 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure>
<p>测试服务启动，你可以在浏览器中输入<a href="https://localhost:4000" target="_blank" rel="external">https://localhost:4000</a> 访问了。</p>
<h6 id="3-5-发布"><a href="#3-5-发布" class="headerlink" title="3.5 发布"></a>3.5 发布</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</div></pre></td></tr></table></figure>
<p>如果这是你的第一次，终端会让你输入Github 的邮箱和密码，正确输入后，骚等片刻，就会把你的博客上传至Github 了。以后在每次把博客写完后，执行一下这个命令就可以直接发布了，灰常苏胡。</p>
<h4 id="到这里，你的博客已经完成了，在浏览器中输入-http-qcyl-github-io-就能够访问了。"><a href="#到这里，你的博客已经完成了，在浏览器中输入-http-qcyl-github-io-就能够访问了。" class="headerlink" title="到这里，你的博客已经完成了，在浏览器中输入 http://qcyl.github.io 就能够访问了。"></a>到这里，你的博客已经完成了，在浏览器中输入 <a href="http://qcyl.github.io" target="_blank" rel="external">http://qcyl.github.io</a> 就能够访问了。</h4><hr>
<blockquote>
<p>如果你还希望将博客绑定到自己的个人域名下，提升一下逼格，<br>那么请接着往下看，如果暂时不需要的话，以下的内容可暂时忽略。</p>
</blockquote>
<h4 id="4-绑定个人域名"><a href="#4-绑定个人域名" class="headerlink" title="4.绑定个人域名"></a>4.绑定个人域名</h4><h6 id="4-1-购买域名"><a href="#4-1-购买域名" class="headerlink" title="4.1 购买域名"></a>4.1 购买域名</h6><p>如果你还没有个人域名，可前往<a href="https://wanwang.aliyun.com/?utm_content=se_96657&amp;gclid=Cj0KEQjwhMjKBRDjxb31j-aesI4BEiQA7ivN-AkOk2kYl2zH2OJBcrIlT1Zb67lF3zcsOg-tTn5UkjkaAsWb8P8HAQ" target="_blank" rel="external">万网</a>进行购买。</p>
<h6 id="4-2-创建-CNAME-文件"><a href="#4-2-创建-CNAME-文件" class="headerlink" title="4.2 创建 CNAME 文件"></a>4.2 创建 CNAME 文件</h6><ol>
<li>创建 CNAME 文件（注意文件名大写，且没有扩展名）</li>
<li>写入需要绑定的域名，例：blog.qczyl.club</li>
<li>将 CNAME 文件放到blog/theme/next/source目录下</li>
<li>执行$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布到github</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">注: 1. 域名前不需要添加 http 这样的协议</div><div class="line">    2. 如果需要绑定的域名为 ‘www.qczyl.club’,</div><div class="line">    可省略www，直接写为 ‘qczyl.club’，</div><div class="line">    Github Pages会自动将其重定向到 ‘www.qczyl.club’ 上</div><div class="line">    3. CNAME文件需要放到当前使用主题的source目录下</div></pre></td></tr></table></figure>
<h6 id="4-3-添加-CNAME-记录"><a href="#4-3-添加-CNAME-记录" class="headerlink" title="4.3 添加 CNAME 记录"></a>4.3 添加 CNAME 记录</h6><p>登录阿里云管理控制台，选择云解析DNS，给当前域名新增一条CNAME记录。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-f14b3852417588e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="云解析DNS"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-2e58e6931f9f94d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加一条CNAME记录"></p>
<pre><code>注：1.如果你绑定的域名为www.***,则主机记录为www，我这里为blog
    2.记录值为你个人的github pages地址，即username.github.io
</code></pre><p>完成以上这些步骤后，登录到你的github仓库，查看GitHub Pages，显示为你绑定的域名，并且打了对勾，则绑定成功，然后就可在浏览器中输入你自己的域名访问了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-43ce81f9820358fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进入仓库，选择settings"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1787055-24e60c8d9c33c7f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看GitHub Pages"></p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ol>
<li><a href="http://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="external">5分钟 搭建免费个人博客</a></li>
<li><a href="http://linyehui.me/2016/03/03/reinstall-nodejs-on-osx/" target="_blank" rel="external">Mac OSX下重装node.js</a></li>
<li><a href="https://kikoroc.com/2016/05/04/resolve-hexo-DTraceProviderBindings-MODULE-NOT-FOUND.html" target="_blank" rel="external">解决hexo神烦的DTraceProviderBindings MODULE_NOT_FOUND</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录自己在搭建个人博客的记录，以及工程中遇到的一些问题。&lt;/p&gt;
&lt;p&gt;废话少说，上干货。&lt;/p&gt;
&lt;h4 id=&quot;1-GitHub仓库&quot;&gt;&lt;a href=&quot;#1-GitHub仓库&quot; class=&quot;headerlink&quot; title=&quot;1. GitHub仓库&quot;&gt;&lt;/
    
    </summary>
    
      <category term="杂学" scheme="http://blog.qczyl.club/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
  </entry>
  
</feed>
